# Copyright (c) 2025 AshokShau
# Licensed under the GNU AGPL v3.0: https://www.gnu.org/licenses/agpl-3.0.html
# Part of the TgMusicBot project. All rights reserved where applicable.
# Modified by Devin - Major modifications and improvements

#  NOTE: DO NOT EDIT THIS FILE UNLESS YOU KNOW WHAT YOU ARE DOING.
#  Configure environment variables using a `.env` file instead.

import os
import shutil
from pathlib import Path
from typing import Optional

from dotenv import load_dotenv

from TgMusic.logger import LOGGER

load_dotenv()


class BotConfig:
    """
    A class to manage and validate all bot configuration settings from environment variables.
    """

    def __init__(self):
        # Core Bot Configuration
        self.API_ID: Optional[int] = self._get_env_int("API_ID")
        self.API_HASH: Optional[str] = os.getenv("API_HASH")
        self.TOKEN: Optional[str] = os.getenv("TOKEN")

        self.SESSION_STRINGS: list[str] = self._get_session_strings()
        self.MONGO_URI: Optional[str] = os.getenv("MONGO_URI")
        self.DB_NAME: str = os.getenv("DB_NAME", "MusicBot")
        self.API_URL: str = os.getenv("API_URL", "https://tgmusic.fallenapi.fun")
        self.API_KEY: Optional[str] = os.getenv("API_KEY")

        # Owner and Logger
        self.OWNER_ID: int = self._get_env_int("OWNER_ID", 5938660179)
        self.LOGGER_ID: int = self._get_env_int("LOGGER_ID", -1002166934878)

        # Optional Settings
        self.PROXY: Optional[str] = os.getenv("PROXY")
        self.DEFAULT_SERVICE: str = os.getenv("DEFAULT_SERVICE", "youtube").lower()
        self.MIN_MEMBER_COUNT: int = self._get_env_int("MIN_MEMBER_COUNT", 10)

        self.DOWNLOADS_DIR: Path = Path(os.getenv("DOWNLOADS_DIR", "database/music"))

        self.SUPPORT_GROUP: str = os.getenv(
                "SUPPORT_GROUP", "https://t.me/esports9"
    ) or "https://t.me/esports9"
        self.SUPPORT_CHANNEL: str = os.getenv(
            "SUPPORT_CHANNEL", "https://t.me/hybridUpdates"
        ) or "https://t.me/hybridUpdates"

        self.START_IMG: str = os.getenv(
            "START_IMG", "https://i.pinimg.com/1200x/e8/89/d3/e889d394e0afddfb0eb1df0ab663df95.jpg"
        ) or "https://i.pinimg.com/1200x/e8/89/d3/e889d394e0afddfb0eb1df0ab663df95.jpg"

        self.IGNORE_BACKGROUND_UPDATES: bool = self._get_env_bool(
            "IGNORE_BACKGROUND_UPDATES", True
        )
        self.AUTO_LEAVE: bool = self._get_env_bool("AUTO_LEAVE", True)

        # Cookies
        self.COOKIES_URL: list[str] = self._process_cookie_urls(
            os.getenv("COOKIES_URL")
        )
        self.COOKIES_PATH: Optional[str] = os.getenv("COOKIES_PATH")

        # Developer
        devs_env: Optional[str] = os.getenv("DEVS")
        self.DEVS: list[int] = list(map(int, devs_env.split())) if devs_env else []
        if self.OWNER_ID and self.OWNER_ID not in self.DEVS:
            self.DEVS.append(self.OWNER_ID)

        # Validate configuration
        self._validate_config()

    @staticmethod
    def _get_env_int(name: str, default: Optional[int] = None) -> Optional[int]:
        """
        Retrieve an environment variable and convert it to an integer.

        Args:
            name (str): Environment variable name.
            default (Optional[int]): Fallback value if parsing fails.

        Returns:
            Optional[int]: Parsed integer or the default value.
        """
        value = os.getenv(name)
        try:
            return int(value)
        except (TypeError, ValueError):
            LOGGER.warning(
                "Invalid value for %s: %s (default: %s)", name, value, default
            )
            return default

    @staticmethod
    def _get_env_bool(name: str, default: bool = False) -> bool:
        """
        Retrieve an environment variable and interpret it as a boolean.

        Args:
            name (str): Environment variable name.
            default (bool): Default boolean value.

        Returns:
            bool: Parsed boolean value.
        """
        return os.getenv(name, str(default)).lower() == "true"

    @staticmethod
    def _get_session_strings(prefix: str = "STRING", count: int = 10) -> list[str]:
        """
        Retrieve multiple session strings from the environment.

        Args:
            prefix (str): Prefix of the environment variable.
            count (int): Number of session keys to check.

        Returns:
            list[str]: A list of valid session strings.
        """
        return [
            s.strip() for i in range(1, count + 1) if (s := os.getenv(f"{prefix}{i}"))
        ]

    @staticmethod
    def _process_cookie_urls(value: Optional[str]) -> list[str]:
        """
        Parse space- or comma-separated URLs into a list.

        Args:
            value (Optional[str]): Raw COOKIES_URL env value.

        Returns:
            List[str]: List of cleaned URL strings.
        """
        if not value:
            return []
        return [url.strip() for url in value.replace(",", " ").split() if url.strip()]

    def _validate_config(self) -> None:
        """Validate all required environment configuration values with enhanced error handling."""
        missing = []
        validation_errors = []
        
        # Check required fields
        required_fields = {
            "API_ID": self.API_ID,
            "API_HASH": self.API_HASH,
            "TOKEN": self.TOKEN,
            "MONGO_URI": self.MONGO_URI,
            "LOGGER_ID": self.LOGGER_ID,
            "DB_NAME": self.DB_NAME,
            "START_IMG": self.START_IMG
        }
        
        for name, value in required_fields.items():
            if not value:
                missing.append(name)
        
        if missing:
            validation_errors.append(f"Missing required config: {', '.join(missing)}")

        # Validate data types
        if self.MONGO_URI and not isinstance(self.MONGO_URI, str):
            validation_errors.append("MONGO_URI must be a string")
        
        if self.API_ID and not isinstance(self.API_ID, int):
            validation_errors.append("API_ID must be an integer")
        
        if self.LOGGER_ID and not isinstance(self.LOGGER_ID, int):
            validation_errors.append("LOGGER_ID must be an integer")

        # Validate session strings
        if not self.SESSION_STRINGS:
            validation_errors.append("At least one session string (STRING1–10) is required")
        elif len(self.SESSION_STRINGS) < 1:
            validation_errors.append("At least one valid session string is required")

        # Validate URLs
        if self.SUPPORT_GROUP and not self.SUPPORT_GROUP.startswith(('http://', 'https://', 't.me/')):
            validation_errors.append("SUPPORT_GROUP must be a valid URL")
        
        if self.SUPPORT_CHANNEL and not self.SUPPORT_CHANNEL.startswith(('http://', 'https://', 't.me/')):
            validation_errors.append("SUPPORT_CHANNEL must be a valid URL")
        
        if self.START_IMG and not self.START_IMG.startswith(('http://', 'https://')):
            validation_errors.append("START_IMG must be a valid image URL")

        # Validate numeric ranges
        if self.MIN_MEMBER_COUNT and (self.MIN_MEMBER_COUNT < 1 or self.MIN_MEMBER_COUNT > 1000000):
            validation_errors.append("MIN_MEMBER_COUNT must be between 1 and 1,000,000")

        # Validate service type
        valid_services = ["youtube", "spotify", "jiosaavn", "soundcloud"]
        if self.DEFAULT_SERVICE and self.DEFAULT_SERVICE not in valid_services:
            validation_errors.append(f"DEFAULT_SERVICE must be one of: {', '.join(valid_services)}")

        # Clean up database if needed
        if self.IGNORE_BACKGROUND_UPDATES:
            db_path = Path("database")
            if db_path.exists():
                try:
                    shutil.rmtree(db_path)
                    LOGGER.info("Cleaned up old database directory")
                except Exception as e:
                    validation_errors.append(f"Failed to clean database directory: {e}")

        # Create required directories
        try:
            self.DOWNLOADS_DIR.mkdir(parents=True, exist_ok=True)
            Path("database/photos").mkdir(parents=True, exist_ok=True)
            Path("logs").mkdir(parents=True, exist_ok=True)
            LOGGER.info("Created required directories")
        except Exception as e:
            validation_errors.append(f"Failed to create required directories: {e}")

        # Raise comprehensive error if any validation failed
        if validation_errors:
            error_message = "\n".join([f"• {error}" for error in validation_errors])
            raise ValueError(f"Configuration validation failed:\n{error_message}")
        
        LOGGER.info("Configuration validation passed successfully")


config: BotConfig = BotConfig()
